import writeChangeset from "@changesets/write";
import readChangesets from "@changesets/read";
import fs from "node:fs/promises";
import path from "node:path";
import type { PublicChangedPackage, DependencyChange } from "./types";

/**
 * Generate npm package URL
 */
function getNpmPackageUrl(packageName: string): string {
  return `https://www.npmjs.com/package/${packageName}`;
}

/**
 * Generate a single line summary for a single dependency change
 */
function generateSingleLineSummary(change: DependencyChange): string {
  const link = `[${change.name}](${getNpmPackageUrl(change.name)})`;
  switch (change.type) {
    case "updated":
      return `Updated ${link} (${change.oldVersion} -> ${change.newVersion})`;
    case "added":
      return `Added ${link} (${change.newVersion})`;
    case "removed":
      return `Removed ${link} (${change.oldVersion})`;
  }
}

/**
 * Auto-generated banner comment for changesets
 */
export const AUTO_GENERATED_BANNER = `<!-- This changeset was auto-generated by deps2changesets -->`;

/**
 * Check if a changeset summary contains the auto-generated banner
 */
function isAutoGeneratedChangeset(summary: string): boolean {
  return summary.includes(AUTO_GENERATED_BANNER);
}

/**
 * Generate a human-readable summary from dependency changes
 * @param changes - Non-empty array of dependency changes (empty array is not expected)
 */
function generateSummaryFromChanges(changes: DependencyChange[]): string {
  let content: string;
  if (changes.length === 1) {
    // Single change: return a single line without heading
    content = generateSingleLineSummary(changes[0]);
  } else {
    // Use markdown list format with heading for multiple changes
    content = [
      "Dependencies updated\n",
      ...changes.map((c) => `- ${generateSingleLineSummary(c)}`),
    ].join("\n");
  }

  return `${AUTO_GENERATED_BANNER}\n\n${content}`;
}

/**
 * Result of creating a single changeset
 */
export interface ChangesetResult {
  /** The changeset ID */
  id: string;
  /** Whether this changeset replaced an existing auto-generated one */
  recreated: boolean;
}

/**
 * Create changesets for changed packages
 * If auto-generated changesets already exist for the same packages, they will be removed first.
 * @returns Array of created changesets with recreation status
 */
export async function createChangesets(
  changedPackages: PublicChangedPackage[],
  releaseType: "patch" | "minor" | "major",
  cwd: string
): Promise<ChangesetResult[]> {
  if (changedPackages.length === 0) {
    return [];
  }

  // First, find existing auto-generated changesets for each package
  const changesets = await readChangesets(cwd);
  const existingByPackage = new Map<string, string>();

  for (const changeset of changesets) {
    if (!isAutoGeneratedChangeset(changeset.summary)) {
      continue;
    }
    for (const release of changeset.releases) {
      existingByPackage.set(release.name, changeset.id);
    }
  }

  const results: ChangesetResult[] = [];

  for (const changedPackage of changedPackages) {
    const packageName = changedPackage.package.packageJson.name;
    const existingId = existingByPackage.get(packageName);

    // Remove existing auto-generated changeset if it exists
    if (existingId) {
      const changesetPath = path.join(cwd, ".changeset", `${existingId}.md`);
      await fs.rm(changesetPath);
    }

    const summary = generateSummaryFromChanges(
      changedPackage.dependencyChanges
    );

    const changesetId = await writeChangeset(
      {
        summary,
        releases: [
          {
            name: packageName,
            type: releaseType,
          },
        ],
      },
      cwd
    );

    results.push({
      id: changesetId,
      recreated: existingId !== undefined,
    });
  }

  return results;
}
